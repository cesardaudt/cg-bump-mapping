struct VertexIn{  // input :  vertex we get it from OpenGL
	float4 position	: POSITION;
//	float3 normal	: NORMAL;
	float2 texCoord	: TEXCOORD0;
	float3 tangent	: TEXCOORD1;
	float3 binormal	: TEXCOORD2;
	float3 normal	: TEXCOORD3;
};

struct VertexOut   // Output: the modified input vertex 
{
	float4 position    : POSITION;
	float2 texCoord    : TEXCOORD0;
	float2 normal      : TEXCOORD1;
	float3 lightVector : TEXCOORD2;
};



VertexOut main(VertexIn vIn, //uniform float4x4 modelViewProj,   
                            //uniform sampler2D bumpTex
		const uniform float4x4 modelViewProj,
		const uniform float3 lightPosition)
{
	VertexOut vOut;
/*
	// Get the displacement value from the texture then add it to the position.
	float4 displace = tex2D(bumpTex, vIn.texCoord);
	float4 displacedPos = (float4(vIn.normal * displace.x, 1)) + vIn.position;
	// Tranform to clip space then set output color.
	vOut.position = mul(modelViewProj, displacedPos);
	vOut.texCoord = vIn.texCoord;
//*/

/*
	// Identity:
	vOut.position = mul(modelViewProj, vIn.position);
	vOut.texCoord = vIn.texCoord;
	vOut.normal = vIn.texCoord;
//*/

//*
	// Calculate the light vector
	vOut.lightVector = lightPosition - vIn.position.xyz;

	// Transform the light vector from object space into tangent space
	float3x3 TBNMatrix = float3x3(vIn.tangent, vIn.binormal, vIn.normal);
	vOut.lightVector.xyz = mul(TBNMatrix, vOut.lightVector);
	
	// Transform the current vertex from object space to clip space, since OpenGL isn't doing it for us
	// as long we're using a vertex shader
	vOut.position = mul(modelViewProj, vIn.position);
	
	// Send the texture map coords and normal map coords to the fragment shader
	vOut.texCoord = vIn.texCoord;
	vOut.normal = vIn.texCoord;
//*/

	return vOut;
}
